# مستندات الگوریتم سنجاقک (Dragonfly Algorithm) - پیاده‌سازی پایتون

## 📋 فهرست مطالب
1. [معرفی کلی](#معرفی-کلی)
2. [ساختار فایل‌ها](#ساختار-فایل‌ها)
3. [نصب و راه‌اندازی](#نصب-و-راه‌اندازی)
4. [توضیح توابع اصلی](#توضیح-توابع-اصلی)
5. [راهنمای تست توابع معیار](#راهنمای-تست-توابع-معیار)
6. [مثال‌های کاربردی](#مثال‌های-کاربردی)
7. [تفسیر نتایج](#تفسیر-نتایج)
8. [بهینه‌سازی پارامترها](#بهینه‌سازی-پارامترها)

---

## 🎯 معرفی کلی

الگوریتم سنجاقک (DA) یک الگوریتم بهینه‌سازی فراابتکاری است که از رفتار گروهی سنجاقک‌ها الهام گرفته شده است. این الگوریتم شامل پنج رفتار اصلی است:

- **جداسازی (Separation)**: دوری از همسایه‌ها
- **هم‌راستایی (Alignment)**: هم‌راستا شدن با همسایه‌ها
- **انسجام (Cohesion)**: حرکت به سمت مرکز همسایه‌ها
- **جذب غذا (Food attraction)**: حرکت به سمت بهترین راه‌حل
- **دوری از دشمن (Enemy distraction)**: دوری از بدترین راه‌حل

---

## 📁 ساختار فایل‌ها

```
DA/
├── dragonfly_algorithm.py    # پیاده‌سازی اصلی الگوریتم
├── benchmark_functions.py    # توابع معیار (F1-F23)
├── demo.py                  # نمایش جامع الگوریتم
├── requirements.txt         # وابستگی‌های پایتون
└── README.md               # مستندات انگلیسی
```

---

## ⚙️ نصب و راه‌اندازی

### مرحله 1: نصب وابستگی‌ها
```bash
python3 -m pip install numpy matplotlib scipy
```

### مرحله 2: تست نصب
```bash
python3 -c "import numpy; import matplotlib; print('نصب موفق!')"
```

---

## 🔧 توضیح توابع اصلی

### کلاس `DragonflyAlgorithm`

#### سازنده کلاس
```python
def __init__(self, search_agents_no=40, max_iteration=500):
```
**وظیفه**: مقداردهی اولیه الگوریتم
- `search_agents_no`: تعداد سنجاقک‌ها (پیش‌فرض: 40)
- `max_iteration`: حداکثر تعداد تکرار (پیش‌فرض: 500)

#### تابع مقداردهی اولیه
```python
def initialization(self, dim, ub, lb):
```
**وظیفه**: ایجاد موقعیت‌های تصادفی اولیه برای سنجاقک‌ها
- `dim`: بعد مسئله
- `ub`: مرزهای بالایی
- `lb`: مرزهای پایینی

#### تابع محاسبه فاصله
```python
def distance(self, a, b):
```
**وظیفه**: محاسبه فاصله اقلیدسی بین دو نقطه برای یافتن همسایه‌ها

#### تابع پرواز لوی
```python
def levy(self, d):
```
**وظیفه**: تولید گام پرواز لوی برای اکتشاف زمانی که همسایه‌ای وجود ندارد

#### تابع اصلی بهینه‌سازی
```python
def optimize(self, fobj, dim, lb, ub):
```
**وظیفه**: اجرای کامل الگوریتم سنجاقک
- `fobj`: تابع هدف
- `dim`: بعد مسئله
- `lb`: مرزهای پایینی
- `ub`: مرزهای بالایی

**خروجی**: 
- `best_score`: بهترین امتیاز
- `best_pos`: بهترین موقعیت
- `convergence_curve`: منحنی همگرایی

---

## 🧪 راهنمای تست توابع معیار

### تست تابع کره (F1)
```python
from dragonfly_algorithm import DragonflyAlgorithm
from benchmark_functions import BenchmarkFunctions

# دریافت جزئیات تابع F1
lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F1')

# ایجاد نمونه الگوریتم
da = DragonflyAlgorithm(40, 500)

# اجرای بهینه‌سازی
best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)

print(f"بهترین امتیاز: {best_score}")
print(f"بهترین موقعیت: {best_pos}")
```

### تست تابع روزنبراک (F5)
```python
lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F5')
da = DragonflyAlgorithm(50, 1000)  # افزایش پارامترها برای تابع دشوار
best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
```

### تست تابع راستریگین (F9)
```python
lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F9')
da = DragonflyAlgorithm(60, 800)
best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
```

### تست تابع اکلای (F10)
```python
lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F10')
da = DragonflyAlgorithm(45, 600)
best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
```

---

## 📊 توضیح توابع معیار

### توابع تک‌قله‌ای (Unimodal)

#### F1: تابع کره
- **فرمول**: f(x) = Σ(xi²)
- **بهینه**: x* = (0,0,...,0), f(x*) = 0
- **ویژگی**: ساده‌ترین تابع تست
- **پیشنهاد پارامترها**: 40 سنجاقک، 500 تکرار

#### F5: تابع روزنبراک
- **فرمول**: f(x) = Σ[100(xi+1 - xi²)² + (xi - 1)²]
- **بهینه**: x* = (1,1,...,1), f(x*) = 0
- **ویژگی**: تابع دشوار با دره باریک
- **پیشنهاد پارامترها**: 50 سنجاقک، 1000 تکرار

### توابع چندقله‌ای (Multimodal)

#### F9: تابع راستریگین
- **فرمول**: f(x) = Σ[xi² - 10cos(2πxi)] + 10n
- **بهینه**: x* = (0,0,...,0), f(x*) = 0
- **ویژگی**: دارای نویز و قله‌های محلی
- **پیشنهاد پارامترها**: 60 سنجاقک، 800 تکرار

#### F10: تابع اکلای
- **فرمول**: f(x) = -20exp(-0.2√(Σxi²/n)) - exp(Σcos(2πxi)/n) + 20 + e
- **بهینه**: x* = (0,0,...,0), f(x*) = 0
- **ویژگی**: سطح صاف با قله‌های محلی
- **پیشنهاد پارامترها**: 45 سنجاقک، 600 تکرار

#### F11: تابع گریوانک
- **فرمول**: f(x) = Σxi²/4000 - Πcos(xi/√i) + 1
- **بهینه**: x* = (0,0,...,0), f(x*) = 0
- **ویژگی**: قله‌های منظم و متعدد
- **پیشنهاد پارامترها**: 55 سنجاقک، 700 تکرار

---

## 🎨 مثال‌های کاربردی

### مثال 1: تست سریع
```python
# تست ساده با تابع کره
from dragonfly_algorithm import DragonflyAlgorithm
from benchmark_functions import BenchmarkFunctions

da = DragonflyAlgorithm(30, 200)  # پارامترهای کوچک برای تست سریع
lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F1')

best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
print(f"نتیجه: {best_score}")
```

### مثال 2: مقایسه توابع
```python
import matplotlib.pyplot as plt

functions = ['F1', 'F9', 'F10']
results = {}

for func_name in functions:
    lb, ub, dim, fobj = BenchmarkFunctions.get_function_details(func_name)
    da = DragonflyAlgorithm(40, 500)
    best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
    results[func_name] = convergence_curve

# رسم مقایسه
plt.figure(figsize=(12, 8))
for func_name, curve in results.items():
    plt.semilogy(curve, label=func_name)
plt.title('مقایسه همگرایی توابع مختلف')
plt.xlabel('تکرار')
plt.ylabel('بهترین امتیاز')
plt.legend()
plt.grid(True)
plt.show()
```

### مثال 3: مطالعه پارامترها
```python
# مطالعه تأثیر تعداد سنجاقک‌ها
population_sizes = [20, 40, 60, 80]
results = {}

lb, ub, dim, fobj = BenchmarkFunctions.get_function_details('F1')

for pop_size in population_sizes:
    da = DragonflyAlgorithm(pop_size, 300)
    best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)
    results[f'جمعیت {pop_size}'] = convergence_curve

# رسم نتایج
plt.figure(figsize=(10, 6))
for label, curve in results.items():
    plt.semilogy(curve, label=label)
plt.title('تأثیر اندازه جمعیت بر همگرایی')
plt.xlabel('تکرار')
plt.ylabel('بهترین امتیاز')
plt.legend()
plt.grid(True)
plt.show()
```

---

## 📈 تفسیر نتایج

### معیارهای ارزیابی

#### 1. کیفیت راه‌حل
- **امتیاز نزدیک به صفر**: نشان‌دهنده همگرایی خوب
- **امتیاز بالا**: نیاز به تنظیم پارامترها

#### 2. منحنی همگرایی
- **نزول سریع**: الگوریتم کارآمد
- **نزول کند**: نیاز به افزایش تکرارها
- **نوسان**: نیاز به تنظیم پارامترها

#### 3. زمان اجرا
- **زمان کوتاه**: مناسب برای تست
- **زمان طولانی**: نیاز به بهینه‌سازی کد

### مثال تفسیر
```python
# تفسیر نتایج
best_score, best_pos, convergence_curve = da.optimize(fobj, dim, lb, ub)

if best_score < 1e-6:
    print("✅ همگرایی عالی")
elif best_score < 1e-3:
    print("✅ همگرایی خوب")
elif best_score < 1e-1:
    print("⚠️ همگرایی متوسط")
else:
    print("❌ همگرایی ضعیف")

# تحلیل منحنی همگرایی
final_improvement = convergence_curve[0] - convergence_curve[-1]
print(f"بهبود کلی: {final_improvement:.6f}")
```

---

## ⚡ بهینه‌سازی پارامترها

### راهنمای تنظیم پارامترها

#### برای توابع ساده (F1, F2, F3, F4)
```python
da = DragonflyAlgorithm(
    search_agents_no=30,  # تعداد کم
    max_iteration=300     # تکرار کم
)
```

#### برای توابع متوسط (F5, F6, F7, F8)
```python
da = DragonflyAlgorithm(
    search_agents_no=40,  # تعداد متوسط
    max_iteration=500     # تکرار متوسط
)
```

#### برای توابع دشوار (F9, F10, F11)
```python
da = DragonflyAlgorithm(
    search_agents_no=60,  # تعداد زیاد
    max_iteration=800     # تکرار زیاد
)
```

### نکات مهم
1. **تعداد سنجاقک‌ها**: بیشتر = همگرایی بهتر، اما زمان بیشتر
2. **تعداد تکرارها**: بیشتر = دقت بیشتر، اما زمان بیشتر
3. **نسبت بهینه**: تعداد سنجاقک‌ها ≈ 2-3 برابر بعد مسئله

---

## 🚀 اجرای نمایش جامع

برای اجرای نمایش کامل الگوریتم:

```bash
python3 demo.py
```

این دستور شامل:
- تست 5 تابع معیار
- نمایش منحنی‌های همگرایی
- مقایسه توابع مختلف
- مطالعه پارامترها

---

## 📝 نکات مهم

### قبل از استفاده
1. اطمینان از نصب صحیح وابستگی‌ها
2. بررسی محدوده‌های مسئله
3. انتخاب مناسب پارامترها

### هنگام اجرا
1. نظارت بر منحنی همگرایی
2. بررسی زمان اجرا
3. تحلیل کیفیت راه‌حل

### پس از اجرا
1. ذخیره نتایج
2. تحلیل عملکرد
3. تنظیم پارامترها در صورت نیاز

---

## 🔍 عیب‌یابی

### مشکلات رایج

#### خطای "ModuleNotFoundError"
```bash
python3 -m pip install numpy matplotlib scipy
```

#### همگرایی ضعیف
- افزایش تعداد سنجاقک‌ها
- افزایش تعداد تکرارها
- تنظیم محدوده‌های مسئله

#### زمان اجرای طولانی
- کاهش تعداد سنجاقک‌ها
- کاهش تعداد تکرارها
- استفاده از توابع ساده‌تر

---

## 📚 منابع بیشتر

- مقاله اصلی: S. Mirjalili (2015)
- مستندات NumPy: https://numpy.org/doc/
- مستندات Matplotlib: https://matplotlib.org/

---

**نکته**: این مستندات برای استفاده آموزشی و تحقیقاتی تهیه شده است. برای استفاده تجاری، لطفاً مجوزهای لازم را بررسی کنید. 